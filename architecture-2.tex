\section{Серверные вычисления}

\subsection{Формулировка задачи}

В связи с сильно ограниченными вычислительными возможностями на стороне клиента,
было решено отказаться от разработки алгоритмов для обработки геометрии,
выполняемые в браузере.
Таким образом встала задача использования вычислительно сложных алгоритмов для
работы с трехмерной геометрией при условии невозможности реализации этих
алгоритмов на языке JavaScript для исполнения на стороне клиента.

Для решения этой проблемы было решено использовать удаленные серверные
вычисления. При таком подходе необходимо ввести в архитектуру приложения еще
одну сущность - сервер высокопроизводительных вычислений (СВВ). Для начала
опишем роль, которую играет этот объект при выполнении серверных вычислений.

При таком подходе для обсчета геометрии с помощью какого-либо алгоритма будут
сделаны следующие шаги.

\begin{enumerate}
    \item Данные о текущем состоянии геометрии фигуры, отображенной в браузере,
    считываются и передаются на сервер
    \item Сервер сериализует эти данные и передает с помощью какого-либо
    транспорта в СВВ
    \item СВВ десериализует эти данные и передает их на вход алгоритму
    \item СВВ получает результат работы алгоритма, сериализует их и с
    помощью того же транспорта передает на сервер
    \item Сервер десериализует данные и отправляет их клиенту
\end{enumerate}

Таким образом структурно СВВ является некоторой оболочкой над алгоритмом (или
группой алгоритмов), осуществляющий операции сериализации и десериализации
данных, а так же передачи их по назначению с помощью какого-либо транспортного
уровня.

Важно отметить, что данная технология подразумевает наличие модуля сериализации
и десериализации данных как на стороне сервера, так и на стороне СВВ, причем
эти модули должны оперировать одним и тем же форматом данных, но быть
написанными на разных языках программирования (в нашем случае, с одной стороны -
на JavaScript, с другой стороны на С++).

Задача реализации СВВ, а так же модуля сериализации и десериализации данных на
JavaScript была решена с помощью автоматической генерации кода по заданной
модели. Для этого существует две широко применяемые технологии.

\subsection{Protocol Buffers и Apache Thrift}

Для создания приложений с использованием нескольких языков встает проблема
взаимодействия модулей. Традиционным решением является абстракция удаленного
вызова процедур, когда один модуль по средствам заданного протокола кодирует
данные и по средствам транспорта передает их процедуре другого модуля на
обработку. Ответ этой процедуры
кодируется с использованием того же протокола и отправляется вызывавшему.

В описанном выше взаимодействии важную роль играют процессы сериализации и
десериализации
объектов, а так же поддержание согласованности программного кода для выполнения
этих задач на каждом из языков программирования. Для решения этих задач широко
применяется одна из следующих технологий:

\begin{itemize}
    \item Google Protocol Buffers
    \item Apache Thrift
\end{itemize}

Технология Apache Thrift является последователем Google
Protocol Buffers и разработана в свете опыта использованяи последней. Сравнение
двух технологий удобно отображать в виде таблицы.

\begin{center}
\scalebox{0.7}{%
    \begin{tabular}{ | c | c | c |}
    \hline
    & \textbf{Apache Thrift} & \textbf{Google Protocol
    Buffers} \\ \hline
    \textbf{Форматы} & Binary, JSON & Binary \\ \hline
    \textbf{Поддержка ``Node.js''} & Включена в официальную поставку & В виде сторонних
    библиотек \\ \hline
    \textbf{Транспортный уровень} & Включен в официальную поставку & В виде сторонних
    библиотек \\ \hline
    \textbf{Документация} & Посредственная & Очень хорошая \\
    \hline
    \end{tabular}
}
\end{center}

Дополнительно стоит отметить, что быстродействие обоих фреймворков примерно
одинаково, поэтому по совокупности признаков, описанных в таблице, выбор был
сделан в пользу Apache Thrift как наиболее подходящей для поставленных целей и
используемых технологий.

\subsection{Реализация СВВ средствами Apache Thrift}

Apache Thrift\cite{thrift} - технология, разработанная для создания приложений на
разных языках программирования. Для организации такого взаимодействия между
компонентами, написанными на двух языках, требуется использовать модули
сериализации и десериализации, а так же модуль, ответственный за транспортный
уровень передачи
данных, для каждого из языков, участвующих во взаимодействии. Такие модули
создаются процессом генерации кода, который происходит на основе описанной на
специальном языке Thrift модели.

Thrift модель позволяет описывать две сущности: данные, которыми обмениваются
стороны взаимодействия, и сигнатуры процедур, которые одна сторона
предоставляет для удаленного вызова. Одна из сторон взаимодействия является
клиентской и инициирует взаимодействие путем вызова процедур, предоставленных
серверной стороной. Таким образом на основании этих данных Apache Thrift
генерирует код описания данных, код, выполняющий сериализацию и десериализацию
данных, а так же их отправку и прием с помощью транспортного уровня. Кроме этого
генератор создает файл ``MainService\_server.skeleton.cpp'', создержащий наброски
серверной части взаимодействия с заглушками вместо процедур удаленного вызова.

\begin{lstlisting}[caption={Пример описания модели и сервиса для технологии
Thrift}]
struct Point {
    1: double x,
    2: double y
}

service ScaleService {
    Point scalePoint(1:Point point, 2:int scalar)
}
\end{lstlisting}

В нашем случае в качестве сервисов выступают конкретные алгоритмы, выполняющие
удаленные вычисления. Так как эти алгоритмы могут добавляться и исчезать в
процессе развития проекта, то необходимо изменять соответствующим образом
описание сервиса в файле описания thrift, а затем перегенерировать все файлы
ввиду внесенных изменений. После генерации файлов необходимо будет обновить
файл ``server.cpp'', добавив соответствующие директивы ``include'' и исправив
заглушки на вызов соответствующих алгоритмов.

Из всего вышесказанного следует, что для того, чтобы добавить новый алгоритм в
систему, потребуется знание
формата файлов Thrift, а так же четкое понимание внутренней структуры сервиса,
что значительно усложняет процесс расширения функционала всего приложения.

Для того, чтобы облегчить процесс добавления новых алгоритмов, был написан
скрипт ``generate.sh'' для оболочки ``bash'', занимающийся автоматизацией этих
операций. При использовании этого скрипта, процесс добавления новых алгоритмов
для обработки геометрии сводится к следующей цепочки действий
\begin{enumerate}
    \item Файл реализации \texttt{*.cpp} и файл заголовка \texttt{*.h}
    помещаются в папку \texttt{./thrift/algo}. Файл заголовка должен содержать
    только описания функций, обрабатывающих геометрию объекта.
    \item Запускается команда ``bash generate.sh'' из папки \texttt{./thrift},
    которая компилирует серверную часть Thrift
\end{enumerate}

После этого сервер ``./thrift/server'' готов к использованию и может быть
запущен для предоставления сервиса по удаленному использованию процедур. Кроме
этого, на стороне серверной части приложения ``Node.js'' список функций,
доступных для удаленного вызова, автоматически обновился.

Скрипт ``generate.sh'' совершает следующие действия
\begin{enumerate}
    \item Удаляет директории \texttt{gen-nodejs} и \texttt{gen-cpp}, очищая
    таким образом данные, полученные при предыдущих запусках скрипта.
    \item Сканирует папку, содержащую все алгоритмы пользователя, и, анализируя
    все ``*.h'' файлы, найденные в ней, создает соответствующий файл описания
    сервиса для технологии Thrift
    \item С помощью технологии Thrift и на основе файла описания сервиса и
    данных, генерирует код на языке JavaScript для платформы ``Node.js''
    \item Создает файл ``remoteComputing.js'', содержащий функции,
    соответствующие именам найденных функций пользователя. Таким образом на
    стороне серверной части вызов этих функций ничем не будет отличаться
    от вызова любой другой функции из фреймворка ``Node.js''
    \item С помощью технологии Thrift и на основе файла описания сервиса и
    данных, генерирует код на языке C++.
    \item Исправляет файл ``server.cpp'', сгенерированный технологией Thrift,
    убирая в нем заглушки и заменяя их соответствующим вызовом функций
    пользователя
    \item Исправляет использующийся транспорт сервера на соответствующий
    транспорт, используемый в js-части приложения
    \item Компилирует файл ``server.cpp'', получая готовое серверное приложение.
\end{enumerate}

Стоит отдельно отметить пункт 2, включающий в себя анализ ``*.h'' файлов
пользователя. Для этой цели было решено использовать утилиту ``ctags''.
Благодаря ей список функций, определенных среди всех файлов с алгоритмами, можно
получить следующим образом
\begin{lstlisting}[language=bash]
    ctags -x --c-kinds=p *.h | cut -f1 -d' '
\end{lstlisting}

\subsection{Десериализация вещественного типа в Node-Thrift}

В процессе интеграции технологии Apache Thrift в приложение был использован
достаточно молодой модуль ``Node-Thrift'' для платформы ``Node.js'', включающий
в себя
необходимый код для передачи данных с помощью транспорта, а так же сериализацию
и десериализацию простейших типов данных.

К сожалению, после первых экспериментов было установлено, что модуль работает
некорректно. В качестве подтверждения был написан следующий echo-сервис, который
работал ошибочно в условиях взаимодействия компонентов на языках ``Node.js'' и
C++.

\begin{lstlisting}
service EchoService {
    double echo(1:double msg);
}
\end{lstlisting}

В результате генерации кода на основании этого файла описания данных,
клиентское приложение всегда получало 0 в качестве ответа на удаленный
вызов процедуры. Однако проблемы не возникало при использовании любых других
типов данных, отличных от double. Кроме того, проблемы не возникало при
использовании языка Ruby для генерации клиентской части. Из этого следовало, что
ошибка кроется в библиотеке ``Node-Thrift'' для платформы ``Node.js''.
Соответствующий отчет об ошибке был отправлен разработчику.

Ввиду необходимости продолжать разработку, была предпринята попытка устранить
ошибку в библиотеке Node-Thrift самостоятельно. После изучения исходных
кодов модуля было установлена, что ошибка возникает на этапе десериализации
данных и связана с неправильным декодированием 8-байтного вещественного типа.
После обнаружения неисправность была устранена, а соответствующий
патч\cite{nodethriftpatch},
исправляющий проблему, был выслан разработчику модуля.

