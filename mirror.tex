\section{Зеркалирование}

Для ускорения выполнения СВВ была применена сильная оптимизация, позволившая
значительно сократить расходы на передачу данных по сети. Оптимизация
основывается на следующих наблюдениях:
\begin{itemize}
    \item Все деформации геометрии, происходящие на стороне клиента, являются
    детерменированными и полностью задаются входными данными и парамтрами.
    \item На стороне сервера изначальная модель уже есть в формате,
    распазнаваемым фреймворком Thrift.js
\end{itemize}

Исходя из этого можно применить следующий прием: вместо того, чтобы при
необходимости выполнить серверные вычисления пересылать всю геометрию на
веб-сервер, можно переслать только историю примененных преобразований и их
параметров. После этого сервер эмулирует эти преобразования одно за одним и
результат эмуляции передает СВВ в качестве входных аргументов.

Для того, чтобы организовать такое поведение, необходимо решить следующие
технические проблемы.

\subsection{Начальное чтение модели}

Изначально серверу необходимо прочитать и распознать модель, хранящуюся в
закрытом формате трехмерных файлов фреймворка Three.js. Ручной разбор этого
файла представляется довольно сложным занятием, в первую очередь по причине
необходимости постоянной дальнейшей поддержки. Вместо этого было решено
интерпретировать код фреймворка Three.js на стороне сервера и воспользоваться
той его частью, которая ответственная за разбор и представление собственного
формата.

\begin{lstlisting}
var fs = require('fs');
var vm = require('vm');

var t = fs.readFileSync('./public/js-libs/Three.js', 'utf8');

self = {};
window = {};
vm.runInThisContext(t);
\end{lstlisting}

После этого необходимый файл модели можно легко прочитать с использованием
следующей функции

\begin{lstlisting}
function loadModel(path, callback) {

    var l = new THREE.JSONLoader();

    fs.readFile(path, 'utf8', function(err, j) {
        var jj = JSON.parse(j);

        l.createModel(jj, callback);
    });
}
\end{lstlisting}

\subsection{Сессии пользователя}

Ввиду того, что один сервер теперь хранит у себя состояние большого количества
пользователей, возникла необходимость различать различных клиентов. Для этого
был использовн механизм сессий, который для каждого пользователя сервиса
присваивает персональный номер: SessionID. Благодаря этому SessionID, который
передается с каждым запросом пользователя на веб-сервис, у сервера появляется
возможность поддерживать словарь, сопоставляющий для каждого пользователя его
состояние модели.

Поддержка сессий в приложении была реализована с помощью средств фреймворка
Connect.js

\section{Тестирование}

Экспериментальная ветка проекта, реализующая указанную выше асимптотику, была
протестирована на тех же тестах, на которых было проведено изначальное
тестирование.

В результате проведения экспериментов были получены результаты,
сведенные в единую таблицу ~\ref{table:furious}

\begin{table}[ht]
\begin{center}
\scalebox{1.0}{%
    \begin{tabular}{ | c | c | c | c | c | c | }
    \hline
    Количество полигонов & 3098 & 12334 & 23496 & 114344 & 254714 \\
    \hline
    LAN задержка, мс & 213 & 513.5 & 1941.5 & 3718.5 & 12572 \\
    \hline
    3G задержка, мс & 603 & 1571 & 3871 & 6003 & - \\
    \hline
    Взаимодействие node-thrift & 33.5 & 143 & 654 & 1230 & - \\
    \hline
    \end{tabular}
}
\end{center}
\caption{Задержка оптимизированных серверных вычислений}
\label{table:furious}
\end{table}

Таким образом эта оптимизация, почти не изменяя расклад сил на тестах с
использованием LAN, приносит десятикратный прирост в скорости на тесте большого
размера.
