\section{Детали реализации}

\subsection{Клиентские технологии}

\subsubsection{Использование ``Three.js''}

WebGL является достаточно низкоуровневой технологией, предоставляющей
пользователю возможность самостоятельно реализовывать пиксельные и вершинные
шейдеры.
Несмотря на то, что это открывает большие возможности в области создания и
обработки трехмерной графики, это достаточно трудоемкий процесс, часто чреватый
ошибками. Для повышения скорости разработки было решено использовать движок с
открытым исходным кодом ``Three.js''.

``Three.js''\cite{threejs} содержит набор классов, написанных на языке JavaScript, которые
предоставляют многоуровневую абстракцию над процессами создания и отображения
сцены. Пользователи ``Three.js'' избавлены от необходимости самостоятельно писать
шейдерные процедуры \footnote{однако такая возможность в рамках движка им
предоставляется} и могут мыслить объектами и материалами. Все модели
хранятся в виде JavaScript-объектов, которые на каждом этапе рендеринга при
необходимости синхронизируются с буферами WebGL. Важно отметить, что все
 расчеты геометрии (например, пересечение луча с объектами сцены)
программируются на языке JavaScript и выполняются на уровне виртуальной
JavaScript машины, а значит на прямую зависят от ее быстродействия.

\subsubsection{Шаблон Strategy для обеспечения слабой связанности}

В созданном приложении есть два инструмента, которыми пользователь может
взаимодействовать с объектом.
\begin{enumerate}
    \item Инструмент "Рука". Этот инструмент используется для свободного
    вращения объекта вдоль осей
    \item Инструмент "Деформация". Этот инструмент используется для изменения
    геометрии объекта
\end{enumerate}
В процессе написания приложения встала задача разработать такой код, чтобы
добавление новых инструментов в последствии было как можно более простым, а
количество логических связей между разными модулями приложения почти не
увеличивалось. Для этого было решено использовать шаблон проектирования
Strategy, который определяет семейство алгоритмов и обеспечивает их
взаимозаменяемость.

В рамках приложения шаблон Strategy был реализован следующим образов. Каждый
инструмент описывается классом следующего вида
\begin{lstlisting}
function FooTool(context) {
    this.context = context;
}

FooTool.prototype.setUp = function() {
    // set up event listeners for context
}

FooTool.prototype.tearDown = function() {
    // remove all set event listeners
}
\end{lstlisting}

Когда пользователь выбирает инструмент Foo, у текущего контекста вызывается метод \\
\texttt{applyMouseStrategy(FooTool)}, который реализован следующим образом
\begin{lstlisting}
ManagedObject.prototype.applyMouseStrategy = function(Strategy) {
    if (this.mouseStrategy != null) {
        this.mouseStrategy.tearDown();
    }
    this.mouseStrategy = new Strategy(this);
    this.mouseStrategy.setUp();
}
\end{lstlisting}

В этом методе происходит следующая цепочка событий
\begin{enumerate}
    \item Метод проверяет, есть ли какой-нибудь действующий инструмент, и если
    есть, то вызывает у него метод \texttt{tearDown()}.
    \item Создается новый инструмент с помощью переданной в метод
    функции-конструктора класса нового инструмента, созданный объект
    присваивается внутренней переменной выбранного инструмента
    \item У нового инструмента вызывается метод \texttt{setUp()}, который
    устанавливает инструмент на контекст
\end{enumerate}

Таким образом инструменты приложения никак не опираются на остальные
модули приложения, а создание нового инструмента ограничивается только
реализацией его исходного кода и добавлением обработчика события, который бы
активировал нужный инструмент.

\subsubsection{Тесселляция}

На одном из этапов разработки приложения возникла потребность добавить
тесселляцию объектов.

\begin{figure}[htb]
\centering
\includegraphics[width=0.7\textwidth]{holes-in-model.png}
\caption{Отверстия в модели при тесселляции}
\label{fig:holes-in-model}
\end{figure}

Тесселляция - прием, с помощью которого можно увеличить количество
многоугольников в полигональной трёхмерной модели. В процессе тесселляции
объектов, составленных целиком из треугольных полигонов \footnote{В случае
использования четырехугольных полигонов добавление новых вершин необязательно,
достаточно поделить диагональю каждый полигон пополам}, необходимо добавлять
новые вершины. В этом крылась первая проблема: объекты движка ``Three.js'',
загруженные в буферы WebGL, не могут изменить количество вершин, содержащихся в
их геометрии. Так как объект загружается в буферы WebGL при первом отображении
сцены, то для обхода этой проблемы нужно было либо тесселлировать объекты только
один раз до необходимого размера ребра непосредственно после загрузкой и до
отображения сцены, либо динамически тесселлировать объект, удалять его со сцены
и пересоздавать. Преимущество первого метода над вторым в том, что он не
затрагивает производительность приложения и несомненно является более простым в
реализации, однако он не позволяет добиться динамической тесселляции, которая
становится доступной при использовании второго метода. При разработке
планировалось опробовать алгоритм тесселляции с использованием первого метода, а
потом перейти на динамическую тесселляцию при достижении хороших результатов на
первом этапе.

При предварительном тесселлировании объектов и их дальнейшем отображении была
выявлена серия проблем.

\begin{itemize}
    \item При тесселлировании простейших геометрических фигур с четырехугольными
    гранями сбиваются цвета граней
    \item При тесселлировании загруженных *.OBJ-объектов в модели появляются
    отверстия в местах стыках граней
\end{itemize}

Если четырехугольные грани являются довольно редким объектов при задании
геометрии объектов, то второй недостаток существенен при работе с моделями.
Самостоятельное изучение кода тесселляции никаких результатов в
исправлении недостатка алгоритма не дало. Отчет об ошибке вместе с примерами
кода был отправлен разработчикам, а изменения в коде приложения,
связанные с тесселляцией, были вынужденно откачены назад.

\subsubsection{Шина событий}

В процессе разработки приложения встала проблема организации двусторонних
коммуникаций,
которые включали бы в себя как сообщения от отображения к контроллеру, так и
обратные сообщения от контроллера к отображению, инициированные моделью.
Потребность в такого рода взаимодействиях возникла в связи с необходимостью
адаптировать пользовательский интерфейс исходя из тех действий, которые делает
пользователь. Например, если включена опция автоматического вращения модели,
но пользователь попытался самостоятельно повернуть объект с помощью мышки, то
соответствующая опция должна выключиться, а галочка, сигнализирующая об активном
состоянии опции, стать неактивной.

Для решения этой проблемы было решено добавить в архитектуру глобальный объект
\texttt{EventBus}, представляющий собой шину событий.

\begin{lstlisting}
// jQuery based implementation of event bus

var EventBus = {
    subscribe: function(event, fun) {
        $(this).bind(event, fun);
    },
    publish: function(event, arg) {
        $(this).trigger(event, arg);
    }
}
\end{lstlisting}

Шина событий - объект, реализующий простой интерфейс из двух методов:
\begin{enumerate}
    \item \texttt{subscribe(event, callback)} - подписаться на событие
    \texttt{event} с помощью функции обратного вызова \texttt{callback}
    \item \texttt{publish(event, arg)} - вызвать событие
    \texttt{event} с параметром \texttt{arg}
\end{enumerate}

Реализация этого интерфейса, представленная в рамках проекта, основывается на
фреймворке jQuery\cite{jquery}. События задаются строковыми литералами, составленными по правилу
``<Имя класса>:<имя события>''. Правило, составленное таким образом, позволяет
исключить нежелательные пересечения в именах событий. Важно отметить, что на
данный момент следование этому правилу нигде не проверяется и остается на
совести разработчика.

Благодаря шине событий модель приложения получает возможность оповещать
заинтересованных в любых своих внутренних изменениях. Таким образом контроллер
не только передает события от отображения к модели, но и, обрабатывая
соответствующие события модели, получает возможность адаптировать интерфейс так,
чтобы он соответствовал актуальному состоянию модели.

\subsubsection{Инструмент ``Деформация''}

Базовым средством изменения геометрии фигуры является инструмент ``деформация''.
С помощью этого инструмента пользователь может скорректировать геометрию
загруженного объекта.

Использование инструмента происходит по следующей схеме

\begin{enumerate}
    \item Пользователь активирует инструмент в меню инструментов
    \item После наведения мышки на модель, появляется сфера, демонстрирующая
    изменения, которые произойдут с геометрией после применения инструмента на
    этом участке модели.
    \item После одиночного щелчка мыши вершины геометрии, которые попали во
    внутрь сферы, будут спроецированы на ее переднюю поверхность
\end{enumerate}

Инструмент реализован в рамках поведенческого шаблона Strategy. Интересной
особенностью этого инструмента является то, что, ввиду необходимости добавлять
схематичную сферу на сцену для демонстрации последствий деформации, инструмент
вынужден вмешиваться в процесс отображения сцены, при этом не добавляя
дополнительных логических связей между собой и другими модулями приложения. Это
было достигнуто следующим образом.

При создании инструмента (а инструменты создаются непосредственно перед моментом
своей установки) в личном пространстве имен сохраняется функция,
выполняющую отображение сцены.

\begin{lstlisting}
function ModifyingStrategy(mobject) {
    this.managedObject = mobject;
    this.formerRender = mobject.render;
}
\end{lstlisting}

Теперь, в связки с возможностью передавать функциям любой объект,
выступающий в роли ``this'', у нас есть возможность полностью подменить функцию
отображения сцены

\begin{lstlisting}
ModifyingStrategy.prototype.setUp = function() {
    var gthis = this;
    this.managedObject.render = function() {
        // Adding sphere is needed
        ....
        // Calling original rendering method
        gthis.formerRender.call(this);
    }
}
\end{lstlisting}

В класс-ориентированных языках программирования подобный прием мог быть
реализован с помощью наследования и переопределения
виртуальных функций, с последующим вызовом супер-реализации этой функции.

Для того, чтобы задать правильные координаты сферы в сцене, необходимо решить
задачу нахождения координат точки в трехмерном пространстве сцены, на которую
указывает пользователь с помощью мышки. Задача взаимодействия
мышкой с трехмерной сценой является типовой, и в фреймворке ``Three.js'' есть
стандартное
средство для ее решения. Таким средством является объект \texttt{Ray}, который
представляет собой луч, выходящий из точки, и который может быть пересечен с
объектами сцены. Результатом пересечения будет массив точек пересечения,
каждая из которых, однако, задана в локальной координатной системе пересекаемого
объекта. Так как для создания схематичной сферы требуются координаты сцены, то
полученную точку пересечения необходимо перевести из локального пространства
объекта в пространство сцены.

К сожалению, эта задача не решена на уровне фреймворка. Поэтому для её решения
можно
воспользоваться матрицей $matrixWorld$, которая
есть у каждого объекта и которая описывает линейный оператор, переводящий точки
пространства сцены в точки пространства объекта. Благодаря тому, что оператор
является биективным, то для него однозначно определен обратный, который
определяется матрицей $matrixWorld^{-1}$. Таким образом
координаты точки пересечения в пространстве сцены могут быть получены следующим
образом

\begin{lstlisting}
var v = intersection.point.clone();
var m = new THREE.Matrix4().getInverse(mesh.matrixWorld);
m.multiplyVector3(v);
\end{lstlisting}

Теперь рассмотрим непосредственно работу самого алгоритма трансформации. После
того, как пользователь кликнул мышью на какой-либо участок геометрии, все точки,
попавшие внутрь сферы, проецируются на переднюю поверхность сферы. Определим
работу алгоритма более конкретно

А алгоритма есть два параметра: радиус сферы трансформации $R$, а так же
коэффициент заглубления $K$. Их назначение будет пояснено ниже

\begin{enumerate}
    \item Определим точку $p$ модели, на которую кликнул пользователь.
    \item Определим внешнюю нормированную нормаль $\vec{n}$ к модели в этой
    точке. Внешняя нормаль определяет направление проецирования точек геометрии
    \item Рассмотрим вектор $\vec{v} = - R \cdot \vec{n}$,
    направленный в противоположную сторону относительно вектора деформации и по
    модулю равный $R$. Центр сферы $S$ принимается равным $с = p + K \cdot \vec{v}$
    а за радиус берется $R$
    \item Для каждой вершины $u$ геометрии, попадающей внутрь сферы $S$, проверим,
    лежит ли она в первой половине сферы. Для этого достаточно посчитать
    скалярное произведение радиус-векторов
    $$(\vec{u}-\vec{c}) \cdot \vec{n} = |\vec{u}-\vec{c}| \cdot |\vec{n}| \cdot
    cos(\vec{u} \wedge \vec{n})$$
    Знак скалярного произведения будет меньше нуля в том случае,
    если точка лежит во второй половине сферы, удаленной от зрителя. В таком
    случае эту точку проецировать не надо.
    \item Для каждой точки, подлежащей трансформации, происходит проецирование на
    поверхность сферы по направлению, заданному вектором деформации $\vec{n}$
\end{enumerate}

Операция проецирования эквивалентна решению следующей задачи.

Рассмотрим прямую, заданную радиус-вектором $\vec{s}$, задающим точку, которую
надо спроецировать, и вектором направления проекции $\vec{d}$. Тогда точки этой
прямой выражаются следующим уравнением
$$ \vec{p}_{line} = \vec{s} + k \cdot \vec{d} $$

В свою очередь, точки сферы с центром в $(x_c, y_c, z_c)$ в общем виде задаются
следующим уравнением
$$ (x-x_c)^2 + (y-y_c)^2 + (z-z_c)^2 = R^2 $$

Подставив первое уравнение во второе, мы найдем один или два корня. В случае
нахождения одного корня точка уже является спроецированной на сферу.

В случае нахождения двух корней $k_1, k_2$ мы получаем две точки пересечения
сферы и прямой, и при этом если изначальная точка $\vec{s}$ находилась внутри
сферы, то корни будут разных знаков. Так как нас интересует проекция на переднюю
половину сферы, то проекцией будет точка, полученная положительным корнем.

\subsubsection{Использование технологии AJAX}

В ходе разработки сервиса было установлено, что пользователь в процессе работы
совершает многочисленные запросы к серверу, как для загрузки модели в окно
редактора, так и для добавления новой obj-модели в инспектор объектов и вызова
серверных вычислений. Каждое действие требовало перезагрузки страницы, что
значительно ухудшало опыт использования приложения.

В связи с этими причинами было решено полностью перейти к взаимодействию между
клиент-серверной частью по средствам технологии AJAX (Asynchronous Javascript
And XML). Технология AJAX базируется на двух основных принципах

\begin{enumerate}
    \item Использование технологии обращения к серверу без перезагрузки страницы
    \item Использование \texttt{DHTML} для динамического изменения содержимого
    страницы
\end{enumerate}

Классические примеры применения технологии AJAX используют JavaScript-объект
XMLHttpRequest. Однако этот подход чреват проблемами совместимости с некоторыми
старыми браузерами. Например, в браузере Microsoft Internet Explorer объект
XMLHttpRequest не определен, однако есть его аналог с другим именем. Поэтому для
его создания рекомендуется применять подобный код

\begin{lstlisting}
function getXmlHttp(){
  var xmlhttp;
  try {
    xmlhttp = new ActiveXObject("Msxml2.XMLHTTP");
  } catch (e) {
    try {
      xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    } catch (E) {
      xmlhttp = false;
    }
  }
  if (!xmlhttp && typeof XMLHttpRequest!='undefined') {
    xmlhttp = new XMLHttpRequest();
  }
  return xmlhttp;
}
\end{lstlisting}

Изучение тематических ресурсов, посвященных этой технологии, показало, что
объекты XMLHttpRequest, полученные универсальным способом, описанным выше,
несколько отличаются по функциональности. В качестве примера можно привести
метод \texttt{abort()}, который должен обрывать текущий запрос, однако в случае
Internet Explorer этого не делает.

Таким образом, использование XMLHttpRequest порождает целую серию проблем не
только по написанию кросс-браузерного кода, но и по его дальнейшему
сопровождению. Для их решения было решено использовать фреймворк
\texttt{jQuery}, который по мимо специальных функций, ``оборачивающих''
XMLHttpRequest и решающий таким образом многочисленные проблемы с его
использованием, предоставляет поддержку языка запросов к элементам страницы
``XPath'', что значительно облегчает динамическое манипулирование содержимым
страницы.

\subsection{Серверные технологии}

\subsubsection{Фреймворк ``Express.js''}

При разработке web-сервиса были поставлены следующие общие задачи:

\begin{enumerate}
    \item Требуется некоторый механизм сопоставления действий адресам, запрошенным
    пользователем
    \item Необходимо поддерживать возможность генерации html-страниц на основе
    информации, доступной серверу в момент запроса
\end{enumerate}

Для решения этих задач было решено использовать фреймворк для разработки
REST-сервисов на платформе ``Node.js'' под названием ``Express.js''. Фреймворк
состоит из нескольких частей и решает следующие задачи:

\begin{enumerate}
    \item маршрутизация запросов пользователя
    \item разбор тела запроса (в случае передачи форм и загрузки файла)
    \item рендеринг представлений\footnote{подразумевается генерация HTML-кода
    web-страниц, который будет отправлен в ответ на запрос
    пользователя} на основе набора параметров
\end{enumerate}

Фреймворк позволяет строить таблицу маршрутизации запросов с помощью
обработчиков основных глаголов REST-сервисов: REST, POST, PUT, DELETE. Тут
необходимо особо отметить, что протокол связи HTTP 1.0 поддерживает только три
метода: HEAD, GET, POST, а язык разметки HTML вплоть до версии 4.0 не содержит
методов PUT и DELETE в качестве опций для отправки форм на сервер.

Поэтому для того, чтобы ``Express.js'' мог осуществлять маршрутизацию запросов по
отправке форм с глаголами PUT и DELETE, формы должны содержать дополнительно
скрытое поле с именем \texttt{method} и значением, содержащим имя желаемого
метода.

\subsubsection{Рендеринг web-страниц}

Основной задачей рендеринга является формирование страницы, содержащей
информацию, специфическую для данного запроса. Наиболее естественным подходом
для создания таких страниц является использование всевозможных
HTML-препроцессоров, которым можно передать дополнительные параметры.
Так, например, на платформе ``Ruby on Rails'' рендеринг представлений
осуществляется
за счет обработки \texttt{erb}-файлов \footnote{embedded ruby file}, а на
платформе ``Java EE'' для этих целей используются Java Server Pages. Стандартом
де-факто для фреймворка ``Express.js'' является технология Jade.

Jade\cite{jade} - препроцессор HTML-кода, написанный на языке JavaScript. Jade
преобразует код, написанный на специально разработанном DSL\footnote{Domain
Specific Language} (далее - просто язык Jade), в HTML-разметку. Одним из
несомненных достоинств языка Jade является двумерный синтаксис, хорошо себя
зарекомендовавший для описания структур с глубокой вложенностью, а потому
хорошо подходящим для описания компонентов и элементов HTML страницы.

Показательным примером использования технологии Jade будет следующий листинг.
Рассмотрим следующий код на языке Jade

\begin{lstlisting}
!!!
html(lang="en")
  head
    title= pageTitle
    script(type='text/javascript')
      if (foo) {
         bar()
      }
  body
    h1 Jade - node template engine
    #container
      if youAreUsingJade
        p You are amazing
      else
        p Get on it!
\end{lstlisting}

Препроцессор, запущенный на данном коде с параметром \texttt{pageTitle = "Hello,
Jade"}, генерирует следующих HTML-код

\begin{lstlisting}[language=html]
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Jade</title>
    <script type="text/javascript">
      if (foo) {
        bar()
      }
    </script>
  </head>
  <body>
    <h1>Jade - node template engine</h1>
    <div id="container">
      <p>You are amazing</p>
    </div>
  </body>
</html>
\end{lstlisting}

Этот пример иллюстрирует основной способ передачи параметров и использования в
тексте шаблона.

\subsubsection{Загрузка *.obj-объектов}

Одной из главных возможностей приложения является динамическая загрузка
трехмерных объектов, заданных в открытом формате OBJ. К сожалению, сорок восьмая
ревизия фреймворка ``Three.js'', которая используется в приложении, не позволяет
осуществлять динамическую загрузку непосредственно OBJ-моделей и требует
предварительной
конвертации файлов в специального вида JSON-объекты. В стандартную поставку
библиотеки входит скрипт \texttt{convert\_obj\_three.py}, написанный на языке
Python, созданный специально для этих целей. К сожалению, язык
скрипта не позволяет запустить его в браузере на стороне пользователя, а объем
кода в 48 килобайт делают задачу портирования достаточно трудоемкой чреватой на
многочисленные ошибки.

В качестве решения было решено ввести в интерфейс приложения инспектор объектов,
который бы отображал список уже загруженных и объектов,
доступных для динамической загрузки в редактор. Пользователь имеет возможность
удалить любой из объектов инспектора, а так же добавить новые объекты с помощью
специальной формы. При добавления нового объекта пользователем происходит
следующая цепочка событий

\begin{enumerate}
    \item Пользователь через специальную форму выбирает расположенные локально
    на его компьютере OBJ-объекты, которые он хочет увидеть в браузере
    \item Выбранные файлы загружаются на сервер, где с помощью скрипта из
    пакета поставки фреймворка ``Three.js'' преобразуются в необходимый формат и
    сохраняются
    \item При получении успешного ответа сервера при загрузке файлов клиент
    автоматически отправляет запрос на получение нового списка объектов для
    отображения в инспекторе объектов. Пользователь может загрузить любой
    объект из списка
\end{enumerate}

Ввиду того, что типичный сценарий использования приложения не подразумевает
наличия большого количества преобразованных объектов одновременно, было решено
организовать их хранилище на основе файловой системы (ФС). Таким образом все
преобразованные объекты хранятся на сервере в специальной папке
\texttt{./objects}, а основные операции были организованы следующим
образом

\begin{itemize}
    \item ADD. Эта команда должна добавить новый объект в хранилище. В
    случае ФС создается новая папка с именем таким же, как имя объекта, и все
    файлы, относящиеся к объекту, сохраняются в ней
    \item LIST. Эта команда должна вернуть список имен всех объектов. В
    случае ФС она возвращает список имен директорий, находящихся в папке
    \texttt{./objects}
    \item REMOVE. Эта команда должна удалить объект по его имени. В случае
    ФС она удаляет папку с соответствующим именем.
\end{itemize}

Для вызовов внешних процедур изнутри ``Node.js'' использовался метод exec модуля
``child\_process''. Для каждого из действий, вовлекающих использование внешних
вызовов, была разработана соответствующая оболочка на языке JavaScript.

\subsection{Серверные вычисления}

\subsubsection{Формулировка задачи}

Кроме необходимости поддерживать унаследованный от ранее разработанный
desktop-приложений код, было установлено, что возможности скриптового языка
JavaScript в проведении сложных вычислений не велики. Таким образом встала
задача использования вычислительно сложных алгоритмов для работы с трехмерной
геометрией при условии невозможности реализации этих алгоритмов на языке
JavaScript для исполнения на стороне клиента.

Для решения этой проблемы было решено использовать удаленные серверные
вычисления. При таком подходе необходимо ввести в архитектуру приложения еще
одну сущность - сервер высокопроизводительных вычислений (СВВ). Для начала
опишем роль, которую играет этот объект при выполнении серверных вычислений.

При таком подходе для обсчета геометрии с помощью какого-либо алгоритма будут
сделаны следующие шаги.

\begin{enumerate}
    \item Данные о текущем состоянии геометрии фигуры, отображенной в браузере,
    считываются и передаются на сервер
    \item Сервер сериализует эти данные и передает с помощью какого-либо
    транспорта в СВВ
    \item СВВ десериализует эти данные и передает их на вход алгоритму
    \item СВВ получает результат работы алгоритма, сериализует их и с
    помощью того же транспорта передает на сервер
    \item Сервер десериализует данные и отправляет их клиенту
\end{enumerate}

Таким образом структурно СВВ является некоторой оболочкой над алгоритмом (или
группой алгоритмов), осуществляющий операции сериализации и десериализации
данных, а так же передачи их по назначению с помощью какого-либо транспортного
уровня.

Важно отметить, что данная технология подразумевает наличие модуля сериализации
и десериализации данных как на стороне сервера, так и на стороне СВВ, причем
эти модули должны оперировать одним и тем же форматом данных, но быть
написанными на разных языках программирования (в нашем случае, с одной стороны -
на JavaScript, с другой стороны на С++).

Задача реализации СВВ, а так же модуля сериализации и десериализации данных на
JavaScript была решена с помощью автоматической генерации кода по заданной
модели и использованием технологии Apache Thrift.

\subsubsection{Применение thrift-технологии}

Apache Thrift\cite{thrift} - технология, разработанная для создания приложений на
разных языках программирования. Для организации такого взаимодействия между
компонентами, написанными на двух языках, требуется использовать модули
сериализации и десериализации, а так же модуль, ответственный за транспортный
уровень передачи
данных, для каждого из языков, участвующих во взаимодействии. Такие модули
создаются процессом генерации кода, который происходит на основе описанной на
специальном языке Thrift модели.

Thrift модель позволяет описывать две сущности: данные, которыми обмениваются
стороны взаимодействия, и сигнатуры процедур, которые одна сторона
предоставляет для удаленного вызова. Одна из сторон взаимодействия является
клиентской и инициирует взаимодействие путем вызова процедур, предоставленных
серверной стороной. Таким образом на основании этих данных Apache Thrift
генерирует код описания данных, код, выполняющий сериализацию и десериализацию
данных, а так же их отправку и прием с помощью транспортного уровня. Кроме этого
генератор создает файл ``MainService\_server.skeleton.cpp'', создержащий наброски
серверной части взаимодействия с заглушками вместо процедур удаленного вызова.

\begin{lstlisting}[caption={Пример описания модели и сервиса для технологии
Thrift}]
struct Point {
    1: double x,
    2: double y
}

service ScaleService {
    Point scalePoint(1:Point point, 2:int scalar)
}
\end{lstlisting}

В нашем случае в качестве сервисов выступают конкретные алгоритмы, выполняющие
удаленные вычисления. Так как эти алгоритмы могут добавляться и исчезать в
процессе развития проекта, то необходимо изменять соответствующим образом
описание сервиса в файле описания thrift, а затем перегенерировать все файлы
ввиду внесенных изменений. После генерации файлов необходимо будет обновить
файл ``server.cpp'', добавив соответствующие директивы ``include'' и исправив
заглушки на вызов соответствующих алгоритмов.

Из всего вышесказанного следует, что для того, чтобы добавить новый алгоритм в
систему, потребуется знание
формата файлов Thrift, а так же четкое понимание внутренней структуры сервиса,
что значительно усложняет процесс расширения функционала всего приложения.

Для того, чтобы облегчить процесс добавления новых алгоритмов, был написан
скрипт ``generate.sh'' для оболочки ``bash'', занимающийся автоматизацией этих
операций. При использовании этого скрипта, процесс добавления новых алгоритмов
для обработки геометрии сводится к следующей цепочки действий
\begin{enumerate}
    \item Файл реализации \texttt{*.cpp} и файл заголовка \texttt{*.h}
    помещаются в папку \texttt{./thrift/algo}. Файл заголовка должен содержать
    только описания функций, обрабатывающих геометрию объекта.
    \item Запускается команда ``bash generate.sh'' из папки \texttt{./thrift},
    которая компилирует серверную часть Thrift
\end{enumerate}

После этого сервер ``./thrift/server'' готов к использованию и может быть
запущен для предоставления сервиса по удаленному использованию процедур. Кроме
этого, на стороне серверной части приложения ``Node.js'' список функций,
доступных для удаленного вызова, автоматически обновился.

Скрипт ``generate.sh'' совершает следующие действия
\begin{enumerate}
    \item Удаляет директории \texttt{gen-nodejs} и \texttt{gen-cpp}, очищая
    таким образом данные, полученные при предыдущих запусках скрипта.
    \item Сканирует папку, содержащую все алгоритмы пользователя, и, анализируя
    все ``*.h'' файлы, найденные в ней, создает соответствующий файл описания
    сервиса для технологии Thrift
    \item С помощью технологии Thrift и на основе файла описания сервиса и
    данных, генерирует код на языке JavaScript для платформы ``Node.js''
    \item Создает файл ``remoteComputing.js'', содержащий функции,
    соответствующие именам найденных функций пользователя. Таким образом на
    стороне серверной части вызов этих функций ничем не будет отличаться
    от вызова любой другой функции из фреймворка ``Node.js''
    \item С помощью технологии Thrift и на основе файла описания сервиса и
    данных, генерирует код на языке C++.
    \item Исправляет файл ``server.cpp'', сгенерированный технологией Thrift,
    убирая в нем заглушки и заменяя их соответствующим вызовом функций
    пользователя
    \item Исправляет использующийся транспорт сервера на соответствующий
    транспорт, используемый в js-части приложения
    \item Компилирует файл ``server.cpp'', получая готовое серверное приложение.
\end{enumerate}

Стоит отдельно отметить пункт 2, включающий в себя анализ ``*.h'' файлов
пользователя. Для этой цели было решено использовать утилиту ``ctags''.
Благодаря ей список функций, определенных среди всех файлов с алгоритмами, можно
получить следующим образом
\begin{lstlisting}[language=bash]
    ctags -x --c-kinds=p *.h | cut -f1 -d' '
\end{lstlisting}

\subsubsection{Десериализация вещественного типа в Node-Thrift}

В процессе интеграции технологии Apache Thrift в приложение был использован
достаточно молодой модуль ``Node-Thrift'' для платформы ``Node.js'', включающий
в себя
необходимый код для передачи данных с помощью транспорта, а так же сериализацию
и десериализацию простейших типов данных.

К сожалению, после первых экспериментов было установлено, что модуль работает
некорректно. В качестве подтверждения был написан следующий echo-сервис, который
работал ошибочно в условиях взаимодействия компонентов на языках ``Node.js'' и
C++.

\begin{lstlisting}
service EchoService {
    double echo(1:double msg);
}
\end{lstlisting}

В результате генерации кода на основании этого файла описания данных,
клиентское приложение всегда получало 0 в качестве ответа на удаленный
вызов процедуры. Однако проблемы не возникало при использовании любых других
типов данных, отличных от double. Кроме того, проблемы не возникало при
использовании языка Ruby для генерации клиентской части. Из этого следовало, что
ошибка кроется в библиотеке ``Node-Thrift'' для платформы ``Node.js''.
Соответствующий отчет об ошибке был отправлен разработчику.

Ввиду необходимости продолжать разработку, была предпринята попытка устранить
ошибку в библиотеке Node-Thrift самостоятельно. После изучения исходных
кодов модуля было установлена, что ошибка возникает на этапе десериализации
данных и связана с неправильным декодированием 8-байтного вещественного типа.
После обнаружения неисправность была устранена, а соответствующий
патч\cite{nodethriftpatch},
исправляющий проблему, был выслан разработчику модуля.
