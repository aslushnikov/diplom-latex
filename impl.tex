\section{Детали реализации}

\subsection{Клиентские технологии}

\subsubsection{Использование ``Three.js''}

WebGL является достаточно низкоуровневой технологией, в которой большинство
операций выполняется путем определения и исполнения пиксельных и вершинных
шейдеров. Шейдеры - это небольшие функции, написанные на специальном языке
программирования шейдеров, которые выполняются графической картой и которые
осуществляют преобразования вершин или пикселей\cite{webgl-shaders}.
Несмотря на то, что это открывает большие возможности в области создания и
обработки трехмерной графики, это достаточно трудоемкий процесс, часто чреватый
ошибками. Для повышения скорости разработки было решено использовать один из
нескольких фреймворков-оберток вокруг WebGL. Выбор пал на активно развивающийся
проект с открытым исходным кодом ``Three.js''.

``Three.js''\cite{threejs} содержит набор классов, написанных на языке JavaScript, которые
предоставляют многоуровневую абстракцию над процессами создания и отображения
сцены. Пользователи ``Three.js'' избавлены от необходимости самостоятельно писать
шейдерные процедуры \footnote{однако такая возможность в рамках движка им
предоставляется} и могут мыслить объектами и материалами. Все модели
хранятся в виде JavaScript-объектов, которые на каждом этапе рендеринга при
необходимости синхронизируются с буферами WebGL. Важно отметить, что все
 расчеты геометрии (например, пересечение луча с объектами сцены)
программируются на языке JavaScript и выполняются на уровне виртуальной
JavaScript машины, а значит на прямую зависят от ее быстродействия.

\subsubsection{Шаблон Strategy для обеспечения слабой связанности}

В созданном приложении есть два инструмента, которыми пользователь может
взаимодействовать с объектом.
\begin{enumerate}
    \item Инструмент "Рука". Этот инструмент используется для свободного
    вращения объекта вдоль осей
    \item Инструмент "Деформация". Этот инструмент используется для изменения
    геометрии объекта
\end{enumerate}
В процессе написания приложения встала задача разработать такую архитектуру, чтобы
добавление новых инструментов в последствии было как можно более простым, а
количество логических связей между разными модулями приложения при этом почти не
увеличивалось. Для этого было решено использовать шаблон проектирования
Strategy\cite{strategy}, который определяет семейство алгоритмов и обеспечивает их
взаимозаменяемость.

В рамках приложения шаблон Strategy был реализован следующим образов. Каждый
инструмент описывается классом такого вида
\begin{lstlisting}
function FooTool(context) {
    this.context = context;
}

FooTool.prototype.setUp = function() {
    // set up event listeners for context
}

FooTool.prototype.tearDown = function() {
    // remove all set event listeners
}
\end{lstlisting}

Когда пользователь выбирает инструмент Foo, у текущего контекста вызывается метод \\
\texttt{applyMouseStrategy(FooTool)}, который реализован следующим образом
\begin{lstlisting}
ManagedObject.prototype.applyMouseStrategy = function(Strategy) {
    if (this.mouseStrategy != null) {
        this.mouseStrategy.tearDown();
    }
    this.mouseStrategy = new Strategy(this);
    this.mouseStrategy.setUp();
}
\end{lstlisting}

В этом методе происходит следующая цепочка событий
\begin{enumerate}
    \item Метод проверяет, есть ли какой-нибудь действующий инструмент, и если
    есть, то вызывает у него метод \texttt{tearDown()}.
    \item Создается новый инструмент с помощью переданной в метод
    функции-конструктора класса нового инструмента, созданный объект
    присваивается внутренней переменной выбранного инструмента
    \item У нового инструмента вызывается метод \texttt{setUp()}, который
    устанавливает инструмент на контекст
\end{enumerate}

Таким образом инструменты приложения никак не опираются на остальные
модули приложения, а создание нового инструмента ограничивается только
реализацией его исходного кода и добавлением обработчика события, который бы
активировал нужный инструмент.

\subsubsection{Шаблон Observer для дуплексного взаимодействия}

В процессе разработки приложения встала проблема организации двусторонних
коммуникаций, которые включали бы в себя как сообщения от отображения к
контроллеру, так и обратные сообщения от контроллера к отображению,
инициированные моделью.  Потребность в такого рода взаимодействиях возникла в
связи с необходимостью адаптировать пользовательский интерфейс исходя из тех
действий, которые делает пользователь.

Для решения этой проблемы было решено добавить в архитектуру глобальный объект
\texttt{EventBus}, представляющий собой шину событий, и реализующий шаблон
Observer\cite{observer}.

\begin{lstlisting}
// jQuery based implementation of event bus

var EventBus = {
    subscribe: function(event, fun) {
        $(this).bind(event, fun);
    },
    publish: function(event, arg) {
        $(this).trigger(event, arg);
    }
}
\end{lstlisting}

Шина событий - объект, реализующий простой интерфейс из двух методов:
\begin{enumerate}
    \item \texttt{subscribe(event, callback)} - подписаться на событие
    \texttt{event} с помощью функции обратного вызова \texttt{callback}
    \item \texttt{publish(event, arg)} - вызвать событие
    \texttt{event} с параметром \texttt{arg}
\end{enumerate}

Реализация этого интерфейса, представленная в рамках проекта, основывается на
фреймворке jQuery\cite{jquery}. События задаются строковыми литералами, составленными по правилу
``<Имя класса>:<имя события>''. Правило, составленное таким образом, позволяет
исключить нежелательные пересечения в именах событий. Важно отметить, что на
данный момент следование этому правилу нигде не проверяется и остается на
совести разработчика.

Благодаря шине событий модель приложения получает возможность оповещать
о любых своих внутренних изменениях. Таким образом контроллер
не только передает события от отображения к модели, но и, обрабатывая
соответствующие события модели, получает возможность адаптировать интерфейс так,
чтобы он соответствовал актуальному состоянию модели.

\subsubsection{Использование технологии AJAX}

В ходе разработки сервиса было установлено, что пользователь в процессе работы
совершает многочисленные запросы к серверу, как для загрузки модели в окно
редактора, так и для добавления новой obj-модели в инспектор объектов и вызова
серверных вычислений. Каждое действие требовало перезагрузки страницы, что
значительно ухудшало опыт использования приложения.

В связи с этими причинами было решено полностью перейти к взаимодействию между
клиент-серверной частью по средствам технологии AJAX (Asynchronous Javascript
And XML). Технология AJAX базируется на двух основных принципах

\begin{enumerate}
    \item Использование технологии обращения к серверу без перезагрузки страницы
    \item Использование \texttt{DHTML} для динамического изменения содержимого
    страницы
\end{enumerate}

Классические примеры применения технологии AJAX используют JavaScript-объект
XMLHttpRequest. Однако этот подход чреват проблемами совместимости с некоторыми
старыми браузерами. Например, в браузере Microsoft Internet Explorer объект
XMLHttpRequest не определен, однако есть его аналог с другим именем. Поэтому для
его создания рекомендуется применять подобный код

\begin{lstlisting}
function getXmlHttp(){
  var xmlhttp;
  try {
    xmlhttp = new ActiveXObject("Msxml2.XMLHTTP");
  } catch (e) {
    try {
      xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    } catch (E) {
      xmlhttp = false;
    }
  }
  if (!xmlhttp && typeof XMLHttpRequest!='undefined') {
    xmlhttp = new XMLHttpRequest();
  }
  return xmlhttp;
}
\end{lstlisting}

Изучение тематических ресурсов, посвященных этой технологии, показало, что
объекты XMLHttpRequest, полученные универсальным способом, описанным выше,
несколько отличаются по функциональности. В качестве примера можно привести
метод \texttt{abort()}, который должен обрывать текущий запрос, однако в случае
Internet Explorer этого не делает.

Таким образом, использование XMLHttpRequest порождает целую серию проблем не
только по написанию кросс-браузерного кода, но и по его дальнейшему
сопровождению. Для их решения было решено использовать фреймворк
\texttt{jQuery}, который помимо специальных функций, ``оборачивающих''
XMLHttpRequest и решающий таким образом многочисленные проблемы с его
использованием, предоставляет поддержку языка запросов к элементам страницы
``XPath''\cite{xpath}, что значительно облегчает динамическое манипулирование содержимым
страницы.

\subsection{Серверные технологии}

\subsubsection{Фреймворк ``Express.js''}

При разработке web-сервиса были поставлены следующие общие задачи:

\begin{enumerate}
    \item Требуется некоторый механизм сопоставления действий адресам, которые
    были запрошены пользователем
    \item Необходимо поддерживать возможность генерации html-страниц на основе
    информации, доступной серверу в момент запроса
\end{enumerate}

Для решения этих задач было решено использовать фреймворк для разработки
REST-сервисов на платформе ``Node.js'' под названием ``Express.js''. Фреймворк
состоит из нескольких частей и решает следующие задачи:

\begin{enumerate}
    \item маршрутизация запросов пользователя
    \item разбор тела запроса (в случае передачи форм и загрузки файла)
    \item рендеринг представлений\footnote{подразумевается генерация HTML-кода
    web-страниц, который будет отправлен в ответ на запрос
    пользователя} на основе набора параметров
\end{enumerate}

Фреймворк позволяет строить таблицу маршрутизации запросов с помощью
обработчиков основных глаголов REST-сервисов: REST, POST, PUT, DELETE.
Необходимо особо отметить, что протокол связи HTTP 1.0 поддерживает только три
метода\cite{http10}: HEAD, GET, POST, а язык разметки HTML вплоть до версии 4.0
не содержит методов PUT и DELETE в качестве опций для отправки форм на сервер.

Поэтому для того, чтобы ``Express.js'' мог осуществлять маршрутизацию запросов по
отправке форм с глаголами PUT и DELETE, формы должны содержать дополнительно
скрытое поле с именем \texttt{method} и значением, содержащим имя желаемого
метода.

\subsubsection{Рендеринг web-страниц}

Основной задачей рендеринга является формирование страницы, содержащей
информацию, специфическую для данного запроса. Наиболее естественным подходом
для создания таких страниц является использование всевозможных
HTML-препроцессоров, которым можно передать дополнительные параметры.
Так, например, на платформе ``Ruby on Rails'' рендеринг представлений
осуществляется
за счет обработки \texttt{erb}-файлов \footnote{embedded ruby file}, а на
платформе ``Java EE'' для этих целей используются Java Server Pages. Стандартом
де-факто для фреймворка ``Express.js'' является технология Jade.

Jade\cite{jade} - препроцессор HTML-кода, написанный на языке JavaScript. Jade
преобразует код, написанный на специально разработанном DSL\footnote{Domain
Specific Language} (далее - просто язык Jade), в HTML-разметку. Одним из
несомненных достоинств языка Jade является двумерный синтаксис, хорошо себя
зарекомендовавший для описания структур с глубокой вложенностью, а потому
хорошо подходящим для описания компонентов и элементов HTML страницы.

Показательным примером использования технологии Jade будет следующий листинг.
Рассмотрим следующий код на языке Jade

\begin{lstlisting}
!!!
html(lang="en")
  head
    title= pageTitle
    script(type='text/javascript')
      if (foo) {
         bar()
      }
  body
    h1 Jade - node template engine
    #container
      if youAreUsingJade
        p You are amazing
      else
        p Get on it!
\end{lstlisting}

Препроцессор, запущенный на данном коде с параметром \texttt{pageTitle = "Hello,
Jade"}, генерирует следующих HTML-код

\begin{lstlisting}[language=html]
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Jade</title>
    <script type="text/javascript">
      if (foo) {
        bar()
      }
    </script>
  </head>
  <body>
    <h1>Jade - node template engine</h1>
    <div id="container">
      <p>You are amazing</p>
    </div>
  </body>
</html>
\end{lstlisting}

Этот пример иллюстрирует основной способ передачи параметров и использования в
тексте шаблона.

\subsubsection{Загрузка *.obj-объектов}

Одной из главных возможностей приложения является динамическая загрузка
трехмерных объектов, заданных в открытом формате OBJ. К сожалению,
фреймворк ``Three.js'' не позволяет
осуществлять динамическую загрузку непосредственно OBJ-моделей и требует
предварительной
конвертации файлов в специального вида JSON-объекты. В стандартную поставку
библиотеки входит скрипт \texttt{convert\_obj\_three.py}, написанный на языке
Python, созданный специально для этих целей. К сожалению, язык
скрипта не позволяет запустить его в браузере на стороне пользователя, а объем
кода в 48 килобайт делают задачу портирования достаточно трудоемкой, возникает
вероятность многочисленных ошибок.

В качестве решения было преложено ввести в интерфейс приложения инспектор объектов,
который бы отображал список уже сконвертированных объектов,
доступных для динамической загрузки в редактор. Пользователь имеет возможность
удалить любой из объектов инспектора, а так же добавить новые объекты с помощью
специальной формы. При добавления нового объекта пользователем происходит
следующая цепочка событий

\begin{enumerate}
    \item Пользователь через специальную форму выбирает расположенные локально
    на его компьютере OBJ-объекты, которые он хочет увидеть в браузере
    \item Выбранные файлы загружаются на сервер, где с помощью скрипта из
    пакета поставки фреймворка ``Three.js'' преобразуются в необходимый формат и
    сохраняются
    \item При получении успешного ответа сервера при загрузке файлов клиент
    автоматически отправляет запрос на получение нового списка объектов для
    отображения в инспекторе объектов. Пользователь может загрузить любой
    объект из списка
\end{enumerate}

Ввиду того, что типичный сценарий использования приложения не подразумевает
наличия большого количества преобразованных объектов одновременно, было решено
организовать их хранилище на основе файловой системы (ФС). Таким образом все
преобразованные объекты хранятся на сервере в специальной директории
\texttt{./objects}, а основные операции были организованы следующим
образом

\begin{itemize}
    \item ADD. Эта команда должна добавить новый объект в хранилище. В
    случае ФС создается новая директория с именем таким же, как имя объекта, и все
    файлы, относящиеся к объекту, сохраняются в ней
    \item LIST. Эта команда должна вернуть список имен всех объектов. В
    случае ФС она возвращает список имен поддиректорий, находящихся в директории
    \texttt{./objects}
    \item REMOVE. Эта команда должна удалить объект по его имени. В случае
    ФС она удаляет директорию с соответствующим именем.
\end{itemize}

Для вызовов внешних процедур изнутри ``Node.js'' использовался метод exec модуля
``child\_process''. Для каждого из действий, вовлекающих использование внешних
вызовов, была разработана соответствующая оболочка на языке JavaScript.

