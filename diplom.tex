\documentclass[12pt, a4paper]{article}
\usepackage{graphicx}
\usepackage{array}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{color}
\usepackage{listings}
\let\stdsection\section
\renewcommand\section{\newpage\stdsection}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\graphicspath{{./images/}}
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}
\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}
\linespread{1}
\author{Андрей Лушников}
\title{Разработка и реализация алгоритмов деформирования трехмерной геометрии анатомии человека на основе WebGL}
\date{Апрель 2012 год}

\begin{document}
\maketitle

\tableofcontents
\newpage

\section{Введение}
Каждый программный продукт на протяжении всех стадий жизни сопровождает много
разнообразных проблем. Это и проблемы его поддержки, и проблемы переносимости, и
проблемы контроля версий и устаревания. Эти проблемы характерны как для рядовых
программ, которые знакомы каждому пользователю, так и для специализированных
программ, используемых врачами в их ежедневной практике для оценки,
визуализирования и прогнозирования результатов пластических операций. Один из
современных подходов к распространению программного обеспечения, носящий
название ``Software as a Service'' - призван решить целый класс таких проблем.

Software-as-a-Service (далее ``SAAS'') - модель использования программного
обеспечения, при которой программный продукт выполнен в виде Web-приложения, и
разработчик самостоятельно управляет его развитием. Пользователи имеют доступ к
приложению через сеть интернет, при этом они избавлены от затрат, связанных с
установкой, обновлением и поддержкой работоспособности оборудования и
работающего на нем программного обеспечения.

В работе было решено использовать этот подход для создания средства визуализации
и изменения формы 3D моделей.  Цель выполненной работы - создать программу и веб
сервис для визуализации и изменения формы трехмерной модели с использованием
вычислений на сервере. Использование клиент-серверной системы дает возможность
перенести трудоемкие алгоритмы обработки геометрии на серверную часть,
значительно снизив требования для клиентских рабочих станций.

\section{Постановка цели}
Программное обеспечение, разработанное специально для врачей и решающее
различные медицинские задачи, зачастую обладает большим количеством недостатков.
Оно не кроссплатформенно, а его установка зачастую трудоемка. Оно предъявляет
дополнительные требования к рабочим станциям врачей, что сужает область
применения.

Основной задачей данной дипломной работы было разработать программный редактор,
позволяющий загружать и редактировать трехмерную модель, и при этом полностью
следовать модели SAAS, что избавило бы его от большого количества недостатков,
присущих программному обеспечению в общем и медицинскому программному
обеспечению в частности. Тем не менее, необходимо было дополнительно исследовать
возможность переиспользования программных модулей, написанных на С++ для
desktop-приложений редакторов геометрий, в новом редакторе.

\section{Архитектура}
\subsection{Описание архитектуры}
Для выполнения поставленных целей было решено использовать клиент-серверную
архитектуру. В роли клиента выступает web-приложение, предоставляющее
пользователю необходимый интерфейс для взаимодействия, а серверная часть
отвечает за конвертацию OBJ-файлов и выполнение серверных вычислений.

\subsubsection{Клиент}
Клиентская часть была реализована ввиде web-приложения, написанного
на HTML5.0 и Javascript. Для отображения графики используется
перспективная технология WebGL.

WebGL - это библиотека для программного обеспечения, которая расширяет
возможности языка программирования JavaScript, позволяя ему создавать
интерактивную 3D графику внутри любого совместимого с ней веб-браузера. Код на
WebGL выполняется с помощью видеокарты. Технология
разрабатывается промышленным консорциумом Khronos Group, который
специализируется на выработке открытых стандартов интерфейсов программирования в
области создания и воспроизведения динамической графики и звука. Активное
участие в разработке и внедрении стандарта так же принимают разработчики
браузеров Apple Safari, Google Chrome, Mozilla Firefox, Opera,  а также
специалисты компаний AMD и NVidia. На данный момент технология поддерживается в
последних версиях браузеров Safari, Mozilla, Opera и Chrome, а так же в браузере
Internet Explorer вместе с плагином IEWebGL. Среди мобильных устройств данная
технология уже поддерживается в браузере аппарата Nokia N900, а так же в
браузере Safari Mobile начиная с версии операционной системы iOS 4.2
\footnote{стоит отметить, что использование WebGL разрешено в браузере Mobile
Safari только в контексте рекламных объявлений iAd}

\subsubsection{Сервер}
Cервеная часть была реализована на платформе node.js. Эта технология позволяет
исполнять JavaScript на стороне сервера, причем в качестве движка используется
высокопроизводительный V8, разработанный компанией Google.

Преимущества от использования динамического слабо-типизированного
прототипно-ориентированного языка на стороне сервера заметны далеко не сразу.
Однако использование одного и того же языка на стороне клиента и сервера
позволяет переиспользовать код (например, для проверки форм) и снижает затраты
при передаче данных между клиентом и сервером, т.к. код описания модели тоже может
быть переиспользован. Серверные скрипты на JavaScript по своей природе являются
полностью асинхронными, что упрощает масштабирование серверов на Node.js, а
наличие менеджера пакетов npm с большим количеством опубликованных модулей
делает возможным быстрое прототипирование новых возможностей приложения.

\subsubsection{Переиспользование legacy-кода}
Для поддержания возможности переиспользования модулей и алгоритмов, написанных
на С++ в процессе работы над desktop-приложениями, используется технология
Apache Thrift. Эта технология была разработана в Facebook по аналогии с Google
Protocol Buffers и служит для написания приложений на нескольких языках
программирования. Thrift работает следующим образом: по описанной в специальном
файле и на специальном языке модели можно создать файлы описаний этих моделей
для любого из 20 языков, а по описанному на том же thrift-языке rpc-методу можно
сгенерировать thrift-сервер для интересующего языка, обрабатывающий вызов этого
метода.

\subsection{Альтернативы}
В процессе выбора технологий для решения поставленных задач было проведено исследование,
изучающее альтернативные подходы. Ниже изложены изученные альтернативные
подходы, их достоинства и недостатки.

\subsubsection{Flash на стороне пользователя}
%% В каких-каких годах? Проверить по вики!
В начале 2000х годов большую популярность снискала технология Flash,
позволяющая создавать RIA\footnote{Rich Internet Application} и
сильно оживляющая сайты. Технология остается популярной и по сей день,
однако она все больше и больше вытесняется HTML5, в который были добавлены
многие необходимые для успешной конкуренции с платформой Flash компоненты.
За счет своей огромной популярности технология обладает обширным сообществом,
большим количеством учебных материалов и даже движком для обработки и редеренга
3D-графики. Однако вместе с этими большими
преимуществами технология Flash обладает серией больших недостатков.

Во-первых, для успешной работы flash требуется установка специального плагина. Плагин
динамично развивается и обладает только свойством back-compatability
\footnote{Редкая программа обладает свойством forward-compatibility}, а потому он
становится виновником фрагментации кода.

Во-вторых, некоторое время назад компания Apple категорично отказалась от
поддержки Flash технологии на своей мобильной операционной системе iOS. Несмотря
на то, что в то время это решение вызвало ожесточенные споры, спустя некоторое
время компания Adobe свернула все работы по созданию flash-клиента под мобильную
операционную систему Android. В связи с тем, что львиная доля устройств работает
на операционных системах iOS и Android, и что поддержка технологии на этих
устройствах не запланирована, будущее Flash на мобильных устройствах
представляется туманным. По совокупности этих двух факторов технология была
отвергнута.

\subsubsection{unity вместо webGL}
Платформа Unity зарекомендовала себя в качестве мощного средства создания 2D и
3D приложений под консоли и настольные компьютеры под управлением OS X и
Windows. Платформа предоставляет возможность разрабатывать WEB-приложения с
использованием одной из следующих опций:
\begin{itemize}
    \item Использование специального Unity-плагина для браузеров
    \item Использование экспериментального движка на основе Flash
\end{itemize}
Использование технологии Unity позволяет создавать насыщенные графические сцены,
однако двустороннее взаимодействие плагина с javascript-функциями страницы для
создания полноценного RIA затруднено. Необходимость установки плагина для
пользования ресурсом и проприетарность вкупе с высокой стоймостью программы
заставили отказаться от этой технологии.

\subsubsection{Ruby on Rails вместо Express.js/node.js}
Ввиду поставленных задач возникла необходимость использования серверной части в
архитектуре приложения. При разработке любого серверного решения отдельные
акценты ставятся на вопросы масштабирования, а так же возможности быстрого
прототипирования приложения. Этим параметрам удовлетворяют два популярных
серверных решения для подобных задач: фреймворк Ruby on Rails, и платформа
Node.js.

Строго говоря, сравнивать Ruby on Rails и node.js не правильно, т.к. это просто
разные вещи: Ruby on Rails - это фреймворк для создания web-приложений, а
node.js в свою очередь - библиотека для асинхронного чтения-записи. Поэтому
выбор стоял между использованием Ruby on Rails и Express.js.

Node.js - платформа для построения приложений, основанных на асинхронных I/O
операциях. Несмотря на распространненое мнение, платформа не является первой в
своем роде и в некотором роде наследует принципы, заложенные в асинхронном I/O
фреймворке EventMachine для языка программирования Ruby. Однако большим
достоинством этой платформы перед EventMachine можно назвать язык
программирования EcmaScript стандарта 5.0, или JavaScript: благодаря отсутствию
в его спецификации I/O операций (что в некотором смысле удивительно для
web-ориентированного языка), появилась возможность создать необходимую
библиотеку асинхронных I/O операций, которая и стала стандартной при
использовании Node.js-приложений. Благодаря этому все приложения выглядят
однородно, и у программистов просто нет возможности использовать блокирующую
операцию чтения/записи случайно.

С идеалогической точки зрения это очень похожие фреймворки, приспособленные для
создания и быстрого прототипирования REST-сервисов. Ruby on Rails является более
солидным и развитым проектом, нежели express.js. Обе платформы предлагают
менеджеры пакетов и большую библиотеку общедоступных open-source решений для
самых разных задач, что делает прототипирование одинаково легким на обоих
платформах. Однако использование Ruby on Rails налагает на разработчика
необходимость конвертации объектов из одного языка в другой при клиент-серверных
взаимодействиях, а так же заставляет отказаться от потенциальной возможности
переиспользовать некоторые участки кода, написанные для исполнения на стороне
клиента, на стороне сервера.

Ввиду всего вышесказанного было решено использовать Express.js/node.js на
стороне сервера

\subsubsection{Protocol Buffers вместо Apache Thrift}
Для создания приложений с использованием нескольких языков встает проблема
взаимодействия модулей. Традиционным решением является абстракция удаленного
вызова процедур, когда один модуль по средствам какого-нибудь протокола кодирует
данные и передает их процедуре другого модуля на обработку. Ответ этой процедуры
кодируется с использованием того же протокола и отправляется вызывавшему.

В описанном выше взаимодействии важную роль играет сериализация и десериализация
объектов, а так же поддержание согласованности программного кода для выполнения
этих задач на каждом из языков программирования. Для решения этих задач широко
применяется одна из следующих технологий:
\begin{itemize}
    \item Google Protocol Buffers
    \item Apache Thrift
\end{itemize}

Технология Apache Thrift является в некотором роде последователем Google
Protocol Buffers, и разработана была в свете опыта использованяи последней. Сравнение двух технологий удобно отображать в виде сравнительной
таблицы.

\begin{center}
\scalebox{0.7}{%
    \begin{tabular}{ | c | c | c |}
    \hline
    & \textbf{Apache Thrift} & \textbf{Google Protocol
    Buffers} \\ \hline
    \textbf{Форматы} & Binary, JSON & Binary \\ \hline
    \textbf{Поддержка Node.js} & Включена в официальную поставку & В виде сторонних
    библиотек \\ \hline
    \textbf{Транспортный уровень} & Включен в официальную поставку & В виде сторонних
    библиотек \\ \hline
    \textbf{Документация} & Посредственная & Очень хорошая \\
    \hline
    \end{tabular}
}
\end{center}

Допольнительно стоит отметить, что быстродействие обоих фреймворков примерно
одинаково, поэтому по совокупности признаков, описанных в таблице, выбор был
сделан в пользу Apache Thrift.

\section{Детали реализации}
\subsection{Клиентские технологии}
\subsubsection{Движок для 3D графики}
WebGL - является достаточно низкоуровневой технологией, предоставляющей
пользователю возможность самостоятельно писать пиксельные и вершинные шейдеры.
Несмотря на то, что это открывает большие возможности в области создания и
обработки трехмерной графики, это достаточно трудоемкий процесс. Для
удобства и повышения скорости разработки было решено использовать популярный
движок Three.js.

Three.js содержит набор классов, написанных на языке JavaScript, которые
предоставляют высокоуровневую абстракцию над процессами создания и рендеренга
сцены. Пользователи Three.js избавлены от необходимости самостоятельно писать
шейдерные процедуры \footnote{однако такая возможность в рамках движка им
предоставляется} и могут мыслить объектами и материалами. Однако все модели
хранятся в виде javaScript-объектов, которые на каждом этапе рендеренга при
необходимости синхронизируются с буферами WebGL. Важно отметить, что все
высокоуровневые расчеты геометрии (например, пересечение луча с объектами сцены)
программируются на языке javaScript и выполняются на уровне виртуальной
JavaScript машины, а значит на прямую зависят от ее быстродействия.

\subsubsection{Шаблон Strategy для создания инструментов}
В созданном приложении есть два инструмента, которыми пользователь может
взаимодействовать с объектом.
\begin{enumerate}
    \item Инструмент "Рука". Этот инструмент используется для свободного
    вращения объекта вдоль осей
    \item Инструмент "Деформация". Этот инструмент используется для изменения
    геометрии объекта
\end{enumerate}
В процессе написания приложения встала задача разработать такой код, чтобы
добавление новых инструментов в последствии было как можно более безболезненно.
Для этого было решено использовать шаблон проектирования Strategy, который
определяет семейство алгоритмов и обеспечивает их взаимозаменяемость.

В рамках приложения шаблон Strategy был применен следующим образов. Каждый
инструмент описывается классом следующего вида
\begin{lstlisting}
function FooTool(context) {
    this.context = context;
}

FooTool.prototype.setUp = function() {
    // set up event listeners for context
}

FooTool.prototype.tearDown = function() {
    // remove all set event listeners
}
\end{lstlisting}

Когда пользователь выбирает инструмент Foo, у текущего контекста вызывается метод \\
\texttt{applyMouseStrategy(FooTool)}, который написан следующим образом
\begin{lstlisting}
ManagedObject.prototype.applyMouseStrategy = function(Strategy) {
    if (this.mouseStrategy != null) {
        this.mouseStrategy.tearDown();
    }
    this.mouseStrategy = new Strategy(this);
    this.mouseStrategy.setUp();
}
\end{lstlisting}
В этом методе происходит следующая цепочка событий
\begin{enumerate}
    \item Метод проверяет, есть ли какой-нибудь действующий инструмент, и если
    есть, то вызывает у него метод \texttt{tearDown()}.
    \item Создается новый инструмент с помощью переданной в метод
    функции-конструктора класса нового инструмента, созданный объект
    присваевается внутренней переменной выбранного инструмента
    \item У нового инструмента вызывается метод \texttt{setUp()}, который
    устанавливает инструмент на контекст
\end{enumerate}

\subsubsection{Тесселляция}
На некотором этапе разработки приложения возникла потребность добавить
тесселляцию объектов.

\begin{figure}[htb]
\centering
\includegraphics[width=0.8\textwidth]{holes-in-model.png}
\caption{Отверстия в модели при тесселляции}
\label{fig:holes-in-model}
\end{figure}

Тесселляция - технология, с помощью которой возможно увеличить количество
многоугольников в полигональной трёхмерной модели. В процессе тесселляции
объектов, составленных целиком из треугольных полигонов \footnote{В случае
использования четырехугольных полигонов добавление новых вершин необязательно,
достаточно поделить диагональю каждый полигон пополам}, необходимо добавлять
новые вершины. В этом крылась первая проблема: объекты, загруженные в буферы
WebGL, не могут изменить количество вершин, содержащихся в их геометрии. Так как
объект загружается в буферы WebGL при первом рендеренге, то для обхода этой
проблемы нужно было либо тесселлировать объекты только один раз до
необходимого размера ребра непосредственно после загрузки и до рендеренга на
экране, либо тесселлировать объект, удалять его со сцены и пересоздавать.
Преимущество первого метода над вторым в том, что он не повлияет значительно на
скорость работы приложения, однако он не позволяет добиться динамической
тесселляции, которая становится доступной при использовании второго метода.
При разработке планировалось опробовать алгоритм тесселляции с использованием
первого метода, а потом перейти на динамическую тесселляцию при успехе первого
этапа.

При предварительном тесселлировании объектов и их дальнейшем рендеренге была
выявлена серия проблем.

\begin{itemize}
    \item При тесселлировании простейших геометрических фигур с четырехугольыми
    гранями сбиваются цвета граней
    \item При тесселлировании загруженных *.OBJ-объектов в модели появляются
    отверстия в местах стыках граней (Рис. ~\ref{fig:holes-in-model} на странице
    ~\pageref{fig:holes-in-model})
\end{itemize}


Если четырехугольные грани являются довольно редким объектов при построении
геометрии объектов, то второй недостаток существенен при работе с моделями.
Самостоятельное изучение кода тесселляции движка никаких результатов в
исправлении недостатка алгоритма не дало. В багтрекер группы разработчиков был
отправлен соответствующий отчет об ошибке, а изменения в коде приложения,
связанные с тесселляцией, были откачены назад.

\subsubsection{Шина событий}
При разработке приложения встала проблема организации двусторонних коммуникаций,
которые включали бы в себя как сообщения от отображения к контроллеру, так и
обратные сообщения от контроллера к отображению, инициированные моделью.
Необходимость в такого рода взаимодействиях возникла в связи с необходимостью
адаптировать пользовательский интерфейс исходя из тех действий, которые делает
пользователь. Например, если включена опция автоматического вращения модели,
но пользователь попытался самостоятельно повернуть объект с помощью мышки, то
соответствующая опция должна выключиться, а галочка, сигнализирующая об активном
состоянии опции, стать неактивной.

Для решения этой проблемы было решено добавить в архитектуру глобальный объект
\texttt{EventBus}, представляющий собой шину событий.

\begin{lstlisting}
// jQuery based implementation of event bus

var EventBus = {
    subscribe: function(event, fun) {
        $(this).bind(event, fun);
    },
    publish: function(event, arg) {
        $(this).trigger(event, arg);
    }
}
\end{lstlisting}

Шина событий - объект, реализующий простой интерфейс из двух методов:
\begin{enumerate}
    \item \texttt{subscribe(event, callback)} - подписаться на событие
    \texttt{event} с помощью функции обратного вызова \texttt{callback}
    \item \texttt{publish(event, arg)} - вызвать событие
    \texttt{event} с параметром \texttt{arg}
\end{enumerate}

Реализация этого интерфейса, представленная в рамках проекта, основывается на
движке jQuery. События задаются строковыми литералами, составленными по правилу
``<Имя класса>:<имя события>''. Правило, составленное таким образом, позволяет
исключить нежелательные пересечения в именах событий. Важно отметить, что на
данный момент следование этому правилу нигде не проверяется и остается на
совести разработчика.

\subsubsection{Проблема поворота}
Тут надо написать про проблему с поворотом объекта, про разные
координатные системы и про решение этой проблемы ввиде перемножения
матриц
\subsubsection{Инструмент ``Деформация''}
TODO
Базовым средством изменения геометрии фигуры является инструмент ``деформация''.
Этот инструмент осуществляет операцию проецирования вершин геометрии на сферу,
параметры которой можно вариировать для достижения лучшего результата.
Стоит

Тут надо написать про инструмент деформация, рассказать про его формулы,
а так же не забыть его доделать так, чтобы он не изменял те вершины, что
находятся в другом направлении от направления деформации

\subsubsection{Использование технологии AJAX}
В ходе разработки сервиса было установленно, что пользователь в процессе работы
совершает многочисленные запросы к серверу, как для загрузки модели в окно
редактора, так и для добавления новой obj-модели в инспектор объектов. Каждое
это действие требовало перезагрузки страницы, что значительно ухудшало
восприятие приложения.

В связи с этими причинами было решено полностью перейти к взаимодействию между
клиент-серверной частью по средствам технологии AJAX (Asynchronous Javascript
And Xml). Технология AJAX базируется на двух основных принципах
\begin{enumerate}
    \item Использование технологии обращения к серверу без перезагрузки страницы
    \item Использование \texttt{DHTML} для динамического изменения содержимого
    страницы
\end{enumerate}

Классические примеры использования технологии AJAX используют javascript-объект
XMLHttpRequest. Однако этот подход чреват проблемами совместимости с некоторыми
старыми браузерами. Например, в браузере Microsoft Internet Explorer объект
XMLHttpRequest не определен, однако есть его аналог с другим именем. Поэтому для
его создания рекомендуется применять подобный код
\begin{lstlisting}
function getXmlHttp(){
  var xmlhttp;
  try {
    xmlhttp = new ActiveXObject("Msxml2.XMLHTTP");
  } catch (e) {
    try {
      xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    } catch (E) {
      xmlhttp = false;
    }
  }
  if (!xmlhttp && typeof XMLHttpRequest!='undefined') {
    xmlhttp = new XMLHttpRequest();
  }
  return xmlhttp;
}
\end{lstlisting}
Изучение тематических ресурсов, посвященных этой технологии, показало, что
объекты XMLHttpRequest, полученные универсальным способом описанным выше,
несколько отличаются по функциональности. В качестве примера можно привести
метод \texttt{abort()}, который должен обрывать текущий запрос, однако в случае
Internet Explorere этого на самом деле не происходит.

Таким образом, использование XMLHttpRequest порождает целую серию проблем по
написанию кросс-браузерного кода, а так же его дальнейшей поддержки. Для их
решения было решено использовать фреймворк \texttt{jQuery}, который по мимо
специальных функций, ``оборачивающих'' XMLHttpRequest и решающий таким образом
многочисленные проблемы с его использованием, предоставляет поддержку языка
запросов к элементам страницы XPath, что значительно облегчает динамическое
манипулирование контентом.


\subsection{Серверные технологии}

\subsubsection{Фреймворк Express.js}
При разработке web-сервиса были поставлены следующие общие задачи:
\begin{enumerate}
    \item Требуется некоторый механизм сопоставления действий адресам, запрошенным
    пользователем
    \item Необходимо поддерживать возможность генерации html-страниц на основе
    информации, доступной серверу в момент запроса
\end{enumerate}

Для решения этих задач было решено использовать фреймворк для разработки
REST-сервисов на платформе Node.js под названием Express.js. Фреймворк состоит
из нескольких частей и решает следующие задачи:
\begin{enumerate}
    \item маршрутизация запросов пользователя
    \item разбор тела запроса (в случае передачи форм и загрузки файла)
    \item рендеринг представлений\footnote{подразумевается генерация HTML-кода
    веб-страниц, который будет в дальнейшем отправлен в ответ на запрос
    пользователя} на основе набора параметров
\end{enumerate}

Фреймворк позволяет строить таблицу маршрутизации запросов с помощью
обработчиков основных глаголов REST-сервисов: REST, POST, PUT, DELETE. Тут
необходимо особо отметить, что протокол связи HTTP 1.0 поддерживает только три
метода: HEAD, GET, POST, а язык разметки HTML вплоть до версии 4.0 не содержит
методов PUT и DELETE в качестве опций для отправки форм на сервер.

Поэтому для того, чтобы Express.js мог осуществлять маршрутизацию запросов по
отправке форм с глаголами PUT и DELETE, формы должны содержать дополнительно
скрытое поле с именем \texttt{method} и значением, содержащим имя желаемого
метода.

\subsubsection{Рендеринг web-страниц}
Основной задачей рендеренга является формирование страницы, содержащей
информацию, специфическую для данного зарпоса. Наиболее ествественным подходом
для создания таких страниц можно считать использование всевозможных
HTML-препроцессоров, которым можно передать дополнительные параметры.
Так, например, на платформе Ruby on Rails рендеринг представлений осуществляется
за счет препроцессинга \texttt{erb}-файлов \footnote{embedded ruby file}, а на
платформе Java EE для этих целей используются Java Server Pages. Стандартом
де-факто для фреймворка Express.js является технология Jade.

Jade --- препроцессор HTML-кода, написанный на языке JavaScript. Иначе говоря,
Jade преобразует код, написанный на специально разработанном DSL\footnote{Domain
Specific Language} (далее - просто язык Jade), в HTML-разметку. Одним из
несомненных достоинств языка Jade является двумерный синтаксис, хорошо себя
зарекомендовавший для описания структур с множественными вложенностями, а потому
хорошо подходящим для описания компонентов и элементов HTML страницы.

Показательным примером использования технологии Jade будет следующий листинг.
Так, например, рассмотрим следующий код на языке Jade
\begin{lstlisting}
!!!
html(lang="en")
  head
    title= pageTitle
    script(type='text/javascript')
      if (foo) {
         bar()
      }
  body
    h1 Jade - node template engine
    #container
      if youAreUsingJade
        p You are amazing
      else
        p Get on it!
\end{lstlisting}

Препроцессор, запущенный на данном коде с параметром \texttt{pageTitle = "Hello,
Jade"}, выдает такой код

\begin{lstlisting}[language=html]
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Jade</title>
    <script type="text/javascript">
      if (foo) {
        bar()
      }
    </script>
  </head>
  <body>
    <h1>Jade - node template engine</h1>
    <div id="container">
      <p>You are amazing</p>
    </div>
  </body>
</html>
\end{lstlisting}

\subsubsection{Загрузка *.obj-объектов}
Одной из главных возможностей приложения является динамическая загрузка
трехмерных объектов в открытом формате OBJ. К сожалению, ревизия 48 движка
Three.js, который используется в приложении, не позволяет осуществлять
динамическую загрузку непосредственно OBJ-моделей и требует предварительной
конвертации файлов в специального вида JSON-объекты. В стандартную поставку
библиотеки входит скрипт \texttt{convert\_obj\_three.py}, написанный на языке
Python, созданный специально для этих целей. К сожалению, язык
скрипта не позволяет запустить его в браузере на стороне пользователя, а объемы кода в 48 Кб сильно
усложняют задачу портирования.

В качестве решения было решено ввести в интерфейс приложения инспектор объектов,
который бы отображал список уже загруженных и сконвертированных объектов,
доступных для динамической загрузки в редактор. Пользователь имеет возможность
удалить любой из объектов инспектора, а так же добавить новые объекты с помощью
специальной формы. При добавления нового объекта пользователем было решено
использовать следующую схему.
\begin{enumerate}
    \item Пользователь через специальную форму выбирает расположенные локально
    на его компьютере OBJ-объекты, которые он хочет увидеть в браузере
    \item Выбранные файлы загружаются на сервер, где с помощью скрипта из
    пакета поставки движка Three.js преобразуются в js-файлы и сохраняются
    \item В случае успеха сервер отправляет ответ с кодом HTTP 200
    \item При получении успешного ответа сервера при загрузке файлов клиент
    автоматически отправляет запрос на получение нового списка объектов, который
    в последствии отображается пользователю. Пользователь может загрузить любой
    объект из списка
\end{enumerate}

Ввиду того, что типичный сценарий испоьзования приложения не подразумевает
наличия большого количества преобразованных объектов одновременно, было решено
организовать их хранилище на основе файловой системы (ФС). Таким образом все
преобразованные объекты хранятся на сервере в специальной папке
\texttt{./objects}, а основные операции были организованы следующим
образом
\begin{itemize}
    \item ADD. Эта команда должна добавить новый объект в хранилище. В
    случае ФС создается новая папка с именем таким же, как имя объекта, и все
    файлы, относящиеся к объекту, сохраняются в ней
    \item LIST. Эта команда должна вернуть список имен всех объектов. В
    случае ФС она возвращает список имен директорий, находящихся в папке
    \texttt{./objects}
    \item REMOVE. Эта команда должа удалить объект по его имени. В случае
    ФС она удаляет папку с соответствующим именем.
\end{itemize}

Для вызовов внешних процедур изнутри Node.js использовался метод exec модуля
child\_process. Для каждого из действий, вовлекающих использование внешних
вызовов, была разработана соответствующая оболочка на языке JavaScript.

\subsection{Серверные вычисления}
\subsubsection{Формулировка задачи}
При разработке приложения было установлено, что возможности скриптового языка
JavaScript в проведении сложных вычислений не велики. Таким образом возникла
задача использования вычислительно-сложных алгоритмов для работы с трехмерной
геометрией при условии невозможности переписывания этих алгоритмов на язык
JavaScript для исполнения на стороне клиента браузером.

Для решения этой проблемы было решено использовать удаленные серверные
вычисления. При таком подходе необходимо ввести в архитектуру приложения еще
одну сущность - сервер высокопроизводительных вычислений (СВВ). Для начала
опишем роль, которую играет этот объект при выполнении серверных вычислений.

При таком подходе для обсчета геометрии с помощью какого-либо алгоритма будут
сделаны следующие шаги.
\begin{enumerate}
    \item Данные о текущем состоянии геометрии фигуры, отображенной в браузере,
    считываются и передаются на сервер
    \item Сервер сериализует эти данные и передает с помощью какого-либо
    транспорта в СВВ
    \item СВВ десериализует эти данные и передает их на вход алгоритму
    \item СВВ получает результат работы алгоритма, сериализовывает их и с
    помощью того же транспорта передает на сервер
    \item Сервер десериализует данные и отправляет их клиенту
\end{enumerate}

Таким образом структурно СВВ является некоторой оболочкой над алгоритмом (или
группой алгоритмов), осуществляющий операции сериализации и десериализации
данных, а так же передачи их по назначению с помощью какого-либо транспортного
уровня.

Важно отметить, что данная технология подразумевает наличие модуля сериализации
и десериализации данных как на стороне сервера, так и на стороне СВВ, причем
эти модули должны оперировать одним и тем же форматом данных, но быть
написанными на разных языках программирования (с одной стороны - на JavaScript,
с другой стороны на том же языке, на котором написаны целевые алгоритмы).

Задача реализации СВВ, а так же модуля сериализации и десериализации данных на
JavaScript была решена с помощью автоматической генерации кода по заданной
модели и использованием технологии Apache Thrift.

\subsubsection{Применение thrift-технологии}
Рассказать про то, что есть один файл model.thrift, что он описывает типы
данных, а так же один сервис. Можно даже скопировать частично этот файл сюда, по
крайней мере код описания сервиса так точно. Что по этому файлу генерятся стабы
для С++ и для js, а так же скелет для С++ сервера. Что этот скелет потом
с помощью скрипта-генератора наполняется содержанием на основе содержимого папки
algo, и с помощью готового makefile'а можно быстро собрать готовый
thrift-сервер.
\subsubsection{Проблема с десериализацией 8-байтного вещественного типа}
Тут надо рассказать, что у node-thrift'a была проблема с десериализацией Double,
о том что она была локализована, устранена, и соответствующий патч был послан в
сообщество на рассмотрение
\subsubsection{Организация С++ кода}
Рассказать про то, что С++ код можно писать довольно-таки обособленно,
рассказать про проблему с идентификацией алгоритмов и с решением, включающим в
себя мета-информацию в комментариях к алгоритму, которая парсится специальным
скриптом. Рассказать про специальные ruby-скрипты для пользователя и их опции

\subsection{Деплоинг приложения}
Проблема деплоинга приложения, использование сначала сбоственной машины, а потом
облачного сервиса heroku.com и его стека приложений CEDAR для временного
хостинга приложения


\section{Результат}
\subsection{Общий результат}
Сделано бла-бла-бла, можно сказать, проведен эксперимент по возможности
использования WebGL и что его можно считать удачным.
\subsection{Проведенные тесты}
\subsubsection{Тесты производительности Three.js}
Надо рассказать про некоторое количество конфузов, которые возникли при работе
с движком. Например, про то, что пересечение луча со сценой работает на уровне
JavaScript'a и потому не очень скоростное, хотя и использует отсечения по
описывающей сфере
\subsubsection{Тесты производительности node-thrift}
Рассказать про неожиданное падение в скорости при сериализации объектов в
node-thrift, о некоторых замерах времени, а так же сказать, что это очень плохо
и хотелось бы это пофиксить. Можно зафигачить какую-нибудь табличку со
сравнительными данными.
\subsection{Выводы}
\end{document}
